# 3.3 Tool Calling (函数调用) - 让 AI 拥有"双手"

**目标:** 理解 Gemini Function Calling 机制，学会定义工具、处理调用，让 AI 从"只会说话"变成"能干活"。

---

## 1. 什么是 Tool Calling (Function Calling)?

### 1.1 核心概念

想象你在和一个助手对话：

**传统模式:**
- 你: "现在几点了？"
- AI: "抱歉，我无法获取实时信息，但我可以告诉你如何查看时间…"

**Tool Calling 模式:**
- 你: "现在几点了？"  
- AI 内部: *"我需要调用 `get_current_time` 工具"*  
- 系统: 执行 `get_current_time()` → 返回 "2025-12-07 11:45:24"  
- AI: "现在是 2025年12月7日 11:45:24。"

### 1.2 工作流程

```
┌─────────────────────────────────────────────────────────┐
│  1. 用户提问: "读取 config.json 文件"                    │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│  2. 你告诉 AI 它有哪些工具（Tool Declarations）         │
│     - read_file(file_path: string)                      │
│     - write_file(file_path: string, content: string)    │
│     - run_shell(command: string)                        │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│  3. AI 分析后决定调用工具                                │
│     FunctionCall {                                      │
│       name: "read_file",                                │
│       args: { "file_path": "config.json" }              │
│     }                                                   │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│  4. 你的代码执行工具                                     │
│     const content = readFileSync('config.json')         │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│  5. 将结果返回给 AI                                      │
│     FunctionResponse {                                  │
│       name: "read_file",                                │
│       response: { content: "{...}" }                    │
│     }                                                   │
└──────────────────┬──────────────────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────────────────┐
│  6. AI 综合信息，生成最终回复                            │
│     "文件内容如下：{ ... }"                              │
└─────────────────────────────────────────────────────────┘
```

---

## 2. 实战教程

### 教程 1: 定义你的第一个工具

我们来实现一个 `get_current_time` 工具。

**创建文件:** `packages/core/src/examples/tool-basic.ts`

```typescript
import { GoogleGenAI } from '@google/genai';
import type { FunctionDeclaration } from '@google/genai';
import * as dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
dotenv.config({ path: path.resolve(__dirname, '../../.env') });

// 1. 定义工具的 Schema
const getCurrentTimeTool: FunctionDeclaration = {
  name: 'get_current_time',
  description: '获取当前的日期和时间',
  parametersJsonSchema: {
    type: 'object',
    properties: {},  // 这个工具不需要参数
    required: []
  }
};

// 2. 实现工具的执行逻辑
function executeTool(functionCall: { name: string; args?: Record<string, unknown> }) {
  if (functionCall.name === 'get_current_time') {
    const now = new Date();
    return {
      currentTime: now.toISOString(),
      formatted: now.toLocaleString('zh-CN')
    };
  }
  throw new Error(`Unknown tool: ${functionCall.name}`);
}

async function main() {
  const genAI = new GoogleGenAI({ apiKey: process.env['GEMINI_API_KEY']! });

  // 3. 发送请求，并声明可用的工具
  const result = await genAI.models.generateContent({
    model: 'gemini-2.0-flash',
    contents: [
      { role: 'user', parts: [{ text: '现在几点了？' }] }
    ],
    config: {
      tools: [{
        functionDeclarations: [getCurrentTimeTool]
      }]
    }
  });

  const candidate = result.candidates?.[0];
  if (!candidate) {
    console.log('No response from AI');
    return;
  }

  // 4. 检查 AI 是否调用了工具
  const firstPart = candidate.content?.parts?.[0];
  
  if (firstPart?.functionCall) {
    console.log('AI 决定调用工具:', firstPart.functionCall.name);
    console.log('参数:', firstPart.functionCall.args);

    // 5. 执行工具
    const toolResult = executeTool({
      name: firstPart.functionCall.name,
      args: firstPart.functionCall.args as Record<string, unknown>
    });

    console.log('工具返回:', toolResult);

    // 6. 将结果返回给 AI，让它生成最终回复
    const finalResult = await genAI.models.generateContent({
      model: 'gemini-2.0-flash',
      contents: [
        { role: 'user', parts: [{ text: '现在几点了？' }] },
        { role: 'model', parts: [firstPart] },  // AI 的工具调用
        { 
          role: 'user', 
          parts: [{
            functionResponse: {
              name: firstPart.functionCall.name,
              response: toolResult
            }
          }]
        }
      ],
      config: {
        tools: [{ functionDeclarations: [getCurrentTimeTool] }]
      }
    });

    console.log('\n最终回复:');
    console.log(finalResult.candidates?.[0]?.content?.parts?.[0]?.text);

  } else if (firstPart?.text) {
    // AI 没有调用工具，直接回复了
    console.log('AI 直接回复:', firstPart.text);
  }
}

main().catch(console.error);
```

**运行:**
```bash
npx tsx src/examples/tool-basic.ts
```

---

### 教程 2: 带参数的工具 - 计算器

**创建文件:** `packages/core/src/examples/tool-calculator.ts`

```typescript
import { GoogleGenAI } from '@google/genai';
import type { FunctionDeclaration } from '@google/genai';
import * as dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
dotenv.config({ path: path.resolve(__dirname, '../../.env') });

// 定义一个计算器工具
const calculatorTool: FunctionDeclaration = {
  name: 'calculator',
  description: '执行数学运算（加减乘除）',
  parametersJsonSchema: {
    type: 'object',
    properties: {
      operation: {
        type: 'string',
        description: '运算类型',
        enum: ['add', 'subtract', 'multiply', 'divide']
      },
      a: {
        type: 'number',
        description: '第一个数字'
      },
      b: {
        type: 'number',
        description: '第二个数字'
      }
    },
    required: ['operation', 'a', 'b']
  }
};

function calculate(operation: string, a: number, b: number): number {
  switch (operation) {
    case 'add': return a + b;
    case 'subtract': return a - b;
    case 'multiply': return a * b;
    case 'divide': 
      if (b === 0) throw new Error('Division by zero');
      return a / b;
    default: throw new Error(`Unknown operation: ${operation}`);
  }
}

async function main() {
  const genAI = new GoogleGenAI({ apiKey: process.env['GEMINI_API_KEY']! });

  const userQuestion = '如果我有 15 个苹果，分给 3 个人，每人能分到几个？';
  console.log(`用户: ${userQuestion}\n`);

  const result = await genAI.models.generateContent({
    model: 'gemini-2.0-flash',
    contents: [{ role: 'user', parts: [{ text: userQuestion }] }],
    config: {
      tools: [{ functionDeclarations: [calculatorTool] }]
    }
  });

  const functionCall = result.candidates?.[0]?.content?.parts?.[0]?.functionCall;
  
  if (functionCall) {
    const args = functionCall.args as { operation: string; a: number; b: number };
    console.log(`AI 调用工具: ${functionCall.name}`);
    console.log(`参数: operation=${args.operation}, a=${args.a}, b=${args.b}\n`);

    const calcResult = calculate(args.operation, args.a, args.b);
    console.log(`计算结果: ${calcResult}\n`);

    // 返回结果给 AI
    const finalResponse = await genAI.models.generateContent({
      model: 'gemini-2.0-flash',
      contents: [
        { role: 'user', parts: [{ text: userQuestion }] },
        { role: 'model', parts: [result.candidates![0].content!.parts![0]] },
        {
          role: 'user',
          parts: [{
            functionResponse: {
              name: functionCall.name,
              response: { result: calcResult }
            }
          }]
        }
      ],
      config: {
        tools: [{ functionDeclarations: [calculatorTool] }]
      }
    });

    console.log('AI 最终回复:');
    console.log(finalResponse.candidates?.[0]?.content?.parts?.[0]?.text);
  }
}

main().catch(console.error);
```

---

### 教程 3: 多个工具 + 循环调用

AI 可能会连续调用多个工具。我们需要一个循环来处理。

**创建文件:** `packages/core/src/examples/tool-loop.ts`

```typescript
import { GoogleGenAI } from '@google/genai';
import type { FunctionDeclaration, Content } from '@google/genai';
import * as dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';
import { readFileSync } from 'fs';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
dotenv.config({ path: path.resolve(__dirname, '../../.env') });

// 工具1: 读文件
const readFileTool: FunctionDeclaration = {
  name: 'read_file',
  description: '读取文件内容',
  parametersJsonSchema: {
    type: 'object',
    properties: {
      file_path: { type: 'string', description: '文件路径' }
    },
    required: ['file_path']
  }
};

// 工具2: 搜索文本
const searchTextTool: FunctionDeclaration = {
  name: 'search_text',
  description: '在文本中搜索关键词',
  parametersJsonSchema: {
    type: 'object',
    properties: {
      text: { type: 'string', description: '要搜索的文本' },
      keyword: { type: 'string', description: '搜索关键词' }
    },
    required: ['text', 'keyword']
  }
};

// 工具执行器
function executeTool(name: string, args: Record<string, unknown>) {
  if (name === 'read_file') {
    const filePath = args.file_path as string;
    try {
      // 注意：这里简化处理，实际应该做路径验证
      const content = readFileSync(filePath, 'utf-8');
      return { content };
    } catch (error) {
      return { error: `Failed to read file: ${error}` };
    }
  }
  
  if (name === 'search_text') {
    const text = args.text as string;
    const keyword = args.keyword as string;
    const lines = text.split('\n');
    const matches = lines
      .map((line, index) => ({ line: index + 1, content: line }))
      .filter(item => item.content.includes(keyword));
    
    return { 
      found: matches.length > 0,
      matches: matches.slice(0, 5)  // 最多返回5个匹配
    };
  }

  throw new Error(`Unknown tool: ${name}`);
}

async function main() {
  const genAI = new GoogleGenAI({ apiKey: process.env['GEMINI_API_KEY']! });
  
  const tools = [readFileTool, searchTextTool];
  const history: Content[] = [
    { 
      role: 'user', 
      parts: [{ text: '读取 package.json 并找出所有提到 "gemini" 的行' }] 
    }
  ];

  const MAX_ITERATIONS = 5;  // 防止无限循环
  
  for (let i = 0; i < MAX_ITERATIONS; i++) {
    console.log(`\n--- 第 ${i + 1} 轮 ---`);
    
    const result = await genAI.models.generateContent({
      model: 'gemini-2.0-flash',
      contents: history,
      config: {
        tools: [{ functionDeclarations: tools }]
      }
    });

    const candidate = result.candidates?.[0];
    if (!candidate?.content?.parts) break;

    const parts = candidate.content.parts;
    history.push({ role: 'model', parts });

    // 检查是否有工具调用
    const functionCalls = parts.filter(p => p.functionCall);
    
    if (functionCalls.length === 0) {
      // 没有工具调用，说明AI已经生成最终答案
      console.log('AI 最终回复:');
      console.log(parts.find(p => p.text)?.text || '(无文本)');
      break;
    }

    // 执行所有工具调用
    const responses = functionCalls.map(part => {
      const fc = part.functionCall!;
      console.log(`调用工具: ${fc.name}`);
      console.log(`参数:`, fc.args);
      
      const result = executeTool(fc.name, fc.args as Record<string, unknown>);
      console.log(`结果:`, result);
      
      return {
        functionResponse: {
          name: fc.name,
          response: result
        }
      };
    });

    // 将所有结果添加到历史
    history.push({
      role: 'user',
      parts: responses
    });
  }
}

main().catch(console.error);
```

---

## 3. gemini-cli 中的 Tool 架构

### 3.1 核心设计原则

gemini-cli 的工具系统遵循 **"声明与执行分离"** 的设计：

```typescript
// 第一步：定义工具（声明）
class ReadFileTool extends BaseDeclarativeTool<Params, Result> {
  // schema: 告诉 AI 这个工具是干什么的，有哪些参数
  constructor() {
    super(
      'read_file',           // 工具名
      'ReadFile',            // 显示名
      '读取文件内容',        // 描述
      Kind.Read,             // 类型（读/写/执行等）
      parametersSchema       // JSON Schema
    );
  }

  // 第二步：验证参数
  validateToolParams(params: Params): string | null {
    if (!params.file_path) return 'Missing file_path';
    return null;  // 验证通过
  }

  // 第三步：创建执行实例
  build(params: Params): ToolInvocation {
    return new ReadFileToolInvocation(params);
  }
}

// 第四步：执行逻辑（独立的类）
class ReadFileToolInvocation extends BaseToolInvocation {
  async execute(): Promise<Result> {
    const content = await readFile(this.params.file_path);
    return { llmContent: content, returnDisplay: '文件已读取' };
  }
}
```

**为什么这样设计？**
1. **验证提前**: 在执行前就发现参数错误。
2. **执行隔离**: 每次调用都是独立的实例，不会互相干扰。
3. **可测试性**: 可以单独测试验证逻辑和执行逻辑。
4. **权限控制**: 在 `shouldConfirmExecute()` 中可以询问用户是否允许。

---

## 4. 下一步

现在你已经掌握了 Tool Calling 的基础！下一节（第四阶段）我们将学习：
- 如何注册和管理工具（ToolRegistry）
- 高级工具：MCP（Model Context Protocol）集成
- 安全机制：工具执行的权限控制

**作业:**
1. 运行以上三个示例。
2. 尝试定义一个 `get_weather(city: string)` 工具（可以返回模拟数据）。
3. 阅读 `gemini-cli` 的 `read-file.ts`，理解 gemini-cli 是如何实现工具的。
