# 3.1 Google Gemini API 基础 (手把手教学)

**目标:** 掌握 Google Gemini API 的核心用法，为构建 AI 助手打下基础。我们将使用官方的 `@google/genai` SDK。

## 1. 前置准备

### 1.1 获取 API Key
1.  访问 [Google AI Studio](https://aistudio.google.com/)。
2.  登录你的 Google 账号。
3.  点击左上角的 **"Get API key"**。
4.  点击 **"Create API key"**。
5.  **复制并保存好你的 API Key**。注意：不要将此 Key 提交到 Git 仓库中！

### 1.2 环境准备
确保你已经处于 `ai-cli-project` 项目中，并且已经初始化了 `packages/core`。

在 `packages/core` 目录下安装官方 SDK 和环境变量管理工具：

```bash
cd packages/core
npm install @google/genai dotenv
```

### 1.3 配置环境变量
在 `packages/core` 目录下创建一个 `.env` 文件，用于存放敏感信息：

```env
# packages/core/.env
GEMINI_API_KEY=你的_API_KEY_粘贴在这里
```

同时，确保你的 `.gitignore` 文件中包含了 `.env`，防止泄露。

---

## 2. 实战教程

我们将创建几个简单的脚本来测试 API。建议在 `packages/core/src/examples/` 目录下创建这些文件（如果目录不存在请先创建）。

### 教程 1: Hello Gemini (基础文本生成)

这个例子展示了最简单的“一问一答”模式。

**创建文件:** `packages/core/src/examples/basic.ts`

```typescript
import { GoogleGenAI } from '@google/genai';
import * as dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// 获取当前文件所在目录，用于定位 .env 文件 (如果 .env 在 core 根目录)
const __dirname = path.dirname(fileURLToPath(import.meta.url));
// 假设 .env 在 packages/core 根目录，即 examples 的上两级
dotenv.config({ path: path.resolve(__dirname, '../../.env') });

async function main() {
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) {
    throw new Error('请在 packages/core/.env 文件中设置 GEMINI_API_KEY');
  }

  const genAI = new GoogleGenAI(apiKey);
  
  // 使用 gemini-2.0-flash 模型，它是目前速度最快且免费额度较高的模型
  // 适合开发和测试阶段使用
  const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

  console.log('正在发送请求: "用一句话解释什么是 Monorepo"...');
  
  try {
    const result = await model.generateContent('用一句话解释什么是 Monorepo');
    console.log('\n响应结果:');
    console.log(result.response.text());
  } catch (error) {
    console.error('请求失败:', error);
  }
}

main();
```

**运行方法:**
使用 `ts-node` 或 `esno` (如果你配置了) 运行：
```bash
# 在 packages/core 目录下
npx tsx src/examples/basic.ts
```

---

### 教程 2: 流式响应 (Streaming)

CLI 工具为了提供良好的用户体验（类似打字机效果），**必须**使用流式输出。如果等待所有内容生成完再显示，用户会感觉到明显的卡顿。

**创建文件:** `packages/core/src/examples/stream.ts`

```typescript
import { GoogleGenAI } from '@google/genai';
import * as dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
dotenv.config({ path: path.resolve(__dirname, '../../.env') });

async function main() {
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) throw new Error('Missing API Key');

  const genAI = new GoogleGenAI(apiKey);
  const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

  console.log('正在思考: "写一首关于程序员的五言绝句"...');
  
  // 注意这里使用的是 generateContentStream 而不是 generateContent
  const result = await model.generateContentStream('写一首关于程序员的五言绝句');

  // result.stream 是一个异步可迭代对象 (Async Iterable)
  for await (const chunk of result.stream) {
    // chunk.text() 返回当前片段的文本
    // 使用 process.stdout.write 而不是 console.log，避免自动换行
    process.stdout.write(chunk.text());
  }
  console.log('\n\n完成!');
}

main().catch(console.error);
```

**运行方法:**
```bash
npx tsx src/examples/stream.ts
```

---

### 教程 3: 多轮对话 (Chat Session)

AI 助手需要记住上下文（Context）。`startChat` 方法可以创建一个会话对象，它会自动维护 `history` 数组，将之前的对话记录传给模型。

**创建文件:** `packages/core/src/examples/chat.ts`

```typescript
import { GoogleGenAI } from '@google/genai';
import * as dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
dotenv.config({ path: path.resolve(__dirname, '../../.env') });

async function main() {
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) throw new Error('Missing API Key');

  const genAI = new GoogleGenAI(apiKey);
  const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

  // 1. 启动聊天会话
  // 可以在这里预设一些历史记录，或者 System Prompt (系统指令)
  const chat = model.startChat({
    history: [
      {
        role: 'user',
        parts: [{ text: '你好，我叫 Antigravity。' }],
      },
      {
        role: 'model',
        parts: [{ text: '你好 Antigravity！很高兴认识你。有什么我可以帮你的吗？' }],
      },
    ],
    // generationConfig 可以控制输出参数
    generationConfig: {
      maxOutputTokens: 200, // 限制最大输出长度
      temperature: 0.7,     // 控制随机性 (0.0 - 1.0)
    },
  });

  // 2. 发送新消息
  const userMessage = '刚才我说了我叫什么？';
  console.log(`User: ${userMessage}`);
  
  // 发送消息并获取流式响应
  // chat 对象会自动将 userMessage 添加到 history 中
  const result = await chat.sendMessageStream(userMessage);

  process.stdout.write('Gemini: ');
  for await (const chunk of result.stream) {
    process.stdout.write(chunk.text());
  }
  console.log('\n');
  
  // 3. (可选) 查看当前的历史记录
  // console.log('当前历史记录:', await chat.getHistory());
}

main().catch(console.error);
```

**运行方法:**
```bash
npx tsx src/examples/chat.ts
```

---

### 教程 4: 进阶技巧 (系统指令与安全设置)

在实际的 CLI 开发中，我们需要更精细地控制模型的行为。

**1. System Instruction (系统指令):**
这是给模型的“人设”或“最高指令”。例如，告诉它 "你是一个 CLI 专家，只输出简洁的 Shell 命令"。这比在对话历史里加一句 "Please act as a..." 权重更高、效果更稳定。

**2. Safety Settings (安全设置):**
默认情况下，Gemini 会屏蔽由于仇恨言论、骚扰等原因被标记为不安全的内容。但在编程场景下，有些代码（如 hack 脚本、敏感词变量名）可能会误触拦截。我们需要显式地降低这些阈值 (`BLOCK_NONE` 或 `BLOCK_ONLY_HIGH`)。

**创建文件:** `packages/core/src/examples/advanced.ts`

```typescript
import { GoogleGenAI, HarmCategory, HarmBlockThreshold } from '@google/genai';
import * as dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
dotenv.config({ path: path.resolve(__dirname, '../../.env') });

async function main() {
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) throw new Error('Missing API Key');

  const genAI = new GoogleGenAI(apiKey);
  
  const model = genAI.getGenerativeModel({ 
    model: 'gemini-2.0-flash',
    // 1. 设置系统指令：定义 AI 的角色
    systemInstruction: {
        parts: [{ text: "You are a specialized SQL assistant. You ONLY output raw SQL queries. Do not use Markdown backticks. Do not explain your answer." }]
    },
    // 2. 设置安全等级：防止写代码时被误报拦截
    safetySettings: [
        {
            category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
            threshold: HarmBlockThreshold.BLOCK_NONE,
        },
        {
            category: HarmCategory.HARM_CATEGORY_HARASSMENT,
            threshold: HarmBlockThreshold.BLOCK_NONE,
        },
    ]
  });

  const question = "Write a SQL query to delete the user table."; 
  console.log(`User: ${question}`);
  
  try {
    const result = await model.generateContent(question);
    console.log('Gemini (SQL Only):');
    console.log(result.response.text());
  } catch (e) {
      console.error("Blocked or Error:", e);
  }
}

main().catch(console.error);
```

**运行:**
```bash
npx tsx src/examples/advanced.ts
```

### 教程 5: 错误重试 (Robustness)

网络请求在 CLI 里经常失败（429 Too Many Requests, 超时等）。一个健壮的 CLI 必须有重试机制。虽然 SDK 内部有基础重试，但我们可以自己封装得更好。

**练习 (思考题):**
阅读 `gemini-cli` 源码中的 `packages/core/src/utils/retry.ts`。看看它是如何使用 exponential backoff (指数退避) 算法来处理 429 错误的。
在之后的章节中，我们将直接复用那一套成熟的重试逻辑。

---

## 3. 核心概念解析

1.  **Model (`GenerativeModel`)**:
    *   `gemini-2.0-flash`: 速度快、成本低，适合高频交互和简单任务。
    *   `gemini-1.5-pro`: 推理能力更强，上下文窗口更大，适合复杂任务（如代码分析、长文档阅读）。
    *   在 CLI 中，我们通常允许用户配置模型，或者针对不同任务使用不同模型。

2.  **GenerateContent vs GenerateContentStream**:
    *   `GenerateContent`: 等待整个响应生成完毕后一次性返回。
    *   `GenerateContentStream`: 返回一个流，允许你逐个 Token 地处理响应。**CLI 开发中 99% 的情况应该使用 Stream**。

3.  **ChatSession**:
    *   它是对 `GenerateContent` 的封装。
    *   它在本地维护一个 `history` 列表。
    *   每次 `sendMessage` 时，它会将 `history` + `新消息` 一起发给 API。
    *   **注意 Token 消耗**: 随着对话变长，发送的 Token 数会越来越多。在后续章节（3.2 上下文管理）中，我们将学习如何计算和修剪 Token。

## 4. 本节作业

1.  **完成环境配置**: 获取 Key，安装 SDK，配置 `.env`。
2.  **跑通代码**: 创建并运行上述四个示例文件 (`basic.ts`, `stream.ts`, `chat.ts`, `advanced.ts`)。
3.  **实验**:
    *   修改 `chat.ts`，尝试多问几轮，看看它是否真的记住了。
    *   尝试修改 `temperature` 参数（例如改为 0 或 1），观察对于同一个问题（如“写一首诗”），输出的随机性有何变化。
4.  **思考**:
    *   如果网络断了，`sendMessageStream` 会抛出什么错误？我们应该如何捕获并提示用户？（参考 `gemini-cli` 源码中的错误处理部分）。
